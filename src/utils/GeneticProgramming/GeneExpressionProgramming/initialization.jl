"""
    growGenerator(gpExperimentInfo::GEPInfo, rng::Random.AbstractRNG)

documentation
"""
function growGenerator(gpExperimentInfo::GEPInfo, rng::Random.AbstractRNG)
    functionSet = gpExperimentInfo._functionSet
    terminalSet = deepcopy(gpExperimentInfo._terminalSet)
    headSize = gpExperimentInfo._head
    tailSize = gpExperimentInfo._tail
    repSize = headSize + tailSize

    representation = Array{Node}(undef, repSize)
    prob = length(terminalSet)/(length(terminalSet) + length(functionSet))

    for i=1:headSize
        if rand(rng) < prob
            representation[i] = rand(rng, terminalSet)
        else
            representation[i] = rand(rng, functionSet)
        end
    end

    for i=headSize+1:repSize
        representation[i] = rand(rng, terminalSet)
    end

    return GEPGenotype(representation)
end # function
precompile(growGenerator, tuple(GEPInfo, Random._GLOBAL_RNG))
precompile(growGenerator, tuple(GEPInfo, Random.MersenneTwister))



"""
    fullGenerator(gpExperimentInfo::GEPInfo, rng::Random.AbstractRNG)

documentation
"""
function fullGenerator(gpExperimentInfo::GEPInfo, rng::Random.AbstractRNG)
    functionSet = gpExperimentInfo._functionSet
    terminalSet = deepcopy(gpExperimentInfo._terminalSet)
    headSize = gpExperimentInfo._head
    tailSize = gpExperimentInfo._tail
    repSize = headSize + tailSize

    representation = Array{Node}(undef, repSize)

    for i=1:headSize
        representation[i] = rand(rng, functionSet)
    end

    for i=headSize+1:repSize
        representation[i] = rand(rng, terminalSet)
    end

    return GEPGenotype(representation)
end # function
precompile(fullGenerator, tuple(GEPInfo, Random._GLOBAL_RNG))
precompile(fullGenerator, tuple(GEPInfo, Random.MersenneTwister))



"""
    rampedHalfHalfGenerator(gpExperimentInfo::GEPInfo, popSize::UInt32,
                            rng::Random.AbstractRNG, RHHFactor::Float64 = 0.5)

Initializes a population for a GP problem by the \"ramped half and half\" method,
which creates part of it using the full method, and the other part using the grow
method.

!!! note
    `Self-provided Arguments` are provided by the library, so only `User Arguments` must be provided.

# Self-provided Arguments
- `gpExperimentInfo::GEPInfo`: information about the GP experiment.
- `popSize::UInt32`: size of the population that is going to be created, that is
    to say, the number of individuals of the population.
- `rng::Random.AbstractRNG`: random number generator for random number consistency
    along an experiment.

# User arguments
- `RHHFactor::Float64 = 0.5`: percentage of the population that is going to
    be created by the \"full\" method, the remaining percentage will be created by
    the \"grow\" method.

# Returns
A population of GP individuals generated by the \"ramped half and half\" method.
"""
function rampedHalfHalfGenerator(gpExperimentInfo::GEPInfo, popSize::UInt32,
                                 rng::Random.AbstractRNG, RHHFactor::Float64 = 0.5)

    population = Array{GEPGenotype}(undef, popSize)
    N = popSize - round(Integer, popSize * RHHFactor)

    for i = 1:(popSize-N)
        population[i] = fullGenerator(gpExperimentInfo, rng)
    end

    for i = (popSize-N+1):popSize
        population[i] = growGenerator(gpExperimentInfo, rng)
    end

    return Random.shuffle(rng, population)
end # function
